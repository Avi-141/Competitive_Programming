Here's why I think E was probably easier than even C.

So for E literally the only observation you need to make is that all array elements need to be divisible by atleast 1 number in the array or all elements need to be a multiple of a single number in the array for the array to be stable.

So if n(i) is total possible elements divisible by i then ans = ncr(n(1)-1,k-1) + ncr(n(2)-1,k-1) + and so on. Notice that I'm subtracting 1 because I'm fixing the smallest number in n(i) i.e i and finding the combinations of the rest.

So the code just boils down to:

ll ans=0;
for(int i=1;i<=n;i++){
    ll q=n/i;
    ans=(ans+ncr(q-1,k-1))%p;
}


We iterate over each value v in range [0, 30] and we fix this value to be the maximum value in the segment we will take. We iterate through the array from end to beginning and when we encounter an element with a value greater than our current fixed value v, we set our current best segment value starting from the current idx to 0 (we reset it). Otherwise we take this element and we add it to the best segment we can take starting from the element to the right of this element. Whenever our current segment value is smaller than 0 we set it to 0 again (we will clear the segment). Now for each iteration we set the max possible segment value to current segment value â€” v. This is easy to code and is just O(31 * N) = O(N)

For problem D: We can use the fact that the range of numbers is very small. So, for each number from -30 to +30, we can assume it(let's call it x) as the largest sum and find the maximum sum subarray. For this we can apply modified Kadane's by ignoring the elements > x.


#include <bits/stdc++.h>
using namespace std;
 
int A[100010];
 
int main() {
    int N;
    scanf("%d", &N);
    for (int i = 0; i < N; i++)
        scanf("%d", &A[i]);
    int mx = 0;
    for (int v = 0; v <= 30; v++) {
        int r = 0;
        for (int i = N - 1; i >= 0; i--) {
            if (A[i] <= v)
                r += A[i];
            else
                r = 0;
            r = max(r, 0);
            mx = max(mx, r - v);
        }
    }
    printf("%d\n", mx);
    return 0;
}

#include <bits/stdc++.h>
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl "\n"
#define int long long
 
const int N = 1e5 + 5;
 
int n;
int a[N];
 
int get(int x)
{
	int ans = -1e9;
	for(int i = 1; i <= n; i++)
	{
		if(a[i] > x)
			continue;
		int j = i;
		int cur = 0;
		while(j <= n)
		{
			if(a[j] <= x)
				cur += a[j];
			else
				break;
			ans = max(ans, cur);
			if(cur < 0)
				cur = 0;
			j++;
		}
		i = j;
	}
	ans -= x;
	return ans;
}
 
int32_t main()
{
	IOS;
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	int ans = 0;
	for(int i = -30; i <= 30; i++)
		ans = max(ans, get(i));
	cout << ans;
	return 0;
}


https://codeforces.com/contest/1359/submission/81741311
https://www.youtube.com/channel/UC_U1nBDkHn3Zw_6QHLSZ2Ew
https://cp-algorithms.com/geometry/intersecting_segments.html
https://codeforces.com/profile/BledDest
https://codeforces.com/profile/SecondThread